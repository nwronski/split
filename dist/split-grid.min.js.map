{"version":3,"file":"split-grid.min.js","sources":["../src/util.js","../src/getMatchedCSSRules.js","../src/index.js"],"sourcesContent":["export const getStyles = (rule, ownRules, matchedRules) =>\n    [...ownRules, ...matchedRules]\n        .map(r => r.style[rule])\n        .filter(style => style !== undefined && style !== '')\n\nexport const getGapValue = (unit, size) => {\n    if (size.endsWith(unit)) {\n        return Number(size.slice(0, -1 * unit.length))\n    }\n    return null\n}\n\nexport const firstNonZero = tracks => {\n    // eslint-disable-next-line no-plusplus\n    for (let i = 0; i < tracks.length; i++) {\n        if (tracks[i].numeric > 0) {\n            return i\n        }\n    }\n    return null\n}\n\nconst numeric = (value, unit) => Number(value.slice(0, -1 * unit.length))\n\nconst parseValue = value => {\n    if (value.endsWith('px'))\n        return { value, type: 'px', numeric: numeric(value, 'px') }\n    if (value.endsWith('fr'))\n        return { value, type: 'fr', numeric: numeric(value, 'fr') }\n    if (value.endsWith('%'))\n        return { value, type: '%', numeric: numeric(value, '%') }\n    if (value === 'auto') return { value, type: 'auto' }\n    return null\n}\n\nexport const parse = rule => rule.split(' ').map(parseValue)\n\nexport const combine = (rule, tracks) => {\n    const prevTracks = rule ? rule.split(' ') : []\n\n    tracks.forEach((track, i) => {\n        if (i > prevTracks.length - 1) {\n            throw new Error(\n                `Unable to set size of track index ${i}, there are only ${\n                    prevTracks.length\n                } tracks in the grid layout.`,\n            )\n        }\n\n        prevTracks[i] = track.value\n            ? track.value\n            : `${track.numeric}${track.type}`\n    })\n\n    return prevTracks.join(' ')\n}\n\nexport const getSizeAtTrack = (index, tracks, gap = 0, end = false) => {\n    const newIndex = end ? index + 1 : index\n    const trackSum = tracks\n        .slice(0, newIndex)\n        .reduce((accum, value) => accum + value.numeric, 0)\n    const gapSum = gap ? index * gap : 0\n\n    return trackSum + gapSum\n}\n","export default el =>\n    []\n        .concat(\n            ...Array.from(el.ownerDocument.styleSheets).map(s => {\n                let rules = []\n\n                try {\n                    rules = Array.from(s.cssRules || [])\n                } catch (e) {\n                    // Ignore results on security error\n                }\n\n                return rules\n            }),\n        )\n        .filter(r => {\n            let matches = false\n            try {\n                matches = el.matches(r.selectorText)\n            } catch (e) {\n                // Ignore matching erros\n            }\n\n            return matches\n        })\n","import { getStyles, getGapValue, firstNonZero, getSizeAtTrack, parse } from './util'\nimport getMatchedCSSRules from './getMatchedCSSRules'\n\nconst gridTemplatePropColumns = 'grid-template-columns'\nconst gridTemplatePropRows = 'grid-template-rows'\n\nconst NOOP = () => false\n\nconst defaultWriteStyle = (element, gridTemplateProp, style) => {\n    // eslint-disable-next-line no-param-reassign\n    element.style[gridTemplateProp] = style\n}\n\nconst getOption = (options, propName, def) => {\n    const value = options[propName]\n    if (value !== undefined) {\n        return value\n    }\n    return def\n}\n\nclass Gutter {\n    constructor(direction, options, parentOptions) {\n        this.direction = direction\n        this.element = options.element\n        this.track = options.track\n\n        if (direction === 'column') {\n            this.gridTemplateProp = gridTemplatePropColumns\n            this.gridGapProp = 'grid-column-gap'\n            this.cursor = getOption(\n                parentOptions,\n                'columnCursor',\n                getOption(parentOptions, 'cursor', 'col-resize'),\n            )\n            this.snapOffset = getOption(\n                parentOptions,\n                'columnSnapOffset',\n                getOption(parentOptions, 'snapOffset', 30),\n            )\n            this.dragInterval = getOption(\n                parentOptions,\n                'columnDragInterval',\n                getOption(parentOptions, 'dragInterval', 1),\n            )\n            this.clientAxis = 'clientX'\n            this.optionStyle = getOption(parentOptions, 'gridTemplateColumns')\n        } else if (direction === 'row') {\n            this.gridTemplateProp = gridTemplatePropRows\n            this.gridGapProp = 'grid-row-gap'\n            this.cursor = getOption(\n                parentOptions,\n                'rowCursor',\n                getOption(parentOptions, 'cursor', 'row-resize'),\n            )\n            this.snapOffset = getOption(\n                parentOptions,\n                'rowSnapOffset',\n                getOption(parentOptions, 'snapOffset', 30),\n            )\n            this.dragInterval = getOption(\n                parentOptions,\n                'rowDragInterval',\n                getOption(parentOptions, 'dragInterval', 1),\n            )\n            this.clientAxis = 'clientY'\n            this.optionStyle = getOption(parentOptions, 'gridTemplateRows')\n        }\n\n        this.onDragStart = getOption(parentOptions, 'onDragStart', NOOP)\n        this.onDragEnd = getOption(parentOptions, 'onDragEnd', NOOP)\n        this.onDrag = getOption(parentOptions, 'onDrag', NOOP)\n        this.writeStyle = getOption(\n            parentOptions,\n            'writeStyle',\n            defaultWriteStyle,\n        )\n\n        this.startDragging = this.startDragging.bind(this)\n        this.stopDragging = this.stopDragging.bind(this)\n        this.drag = this.drag.bind(this)\n\n        this.minSizeStart = options.minSizeStart\n        this.minSizeEnd = options.minSizeEnd\n\n        if (options.element) {\n            this.element.addEventListener('mousedown', this.startDragging)\n            this.element.addEventListener('touchstart', this.startDragging)\n        }\n    }\n\n    getDimensions() {\n        const {\n            width,\n            height,\n            top,\n            bottom,\n            left,\n            right,\n        } = this.grid.getBoundingClientRect()\n\n        if (this.direction === 'column') {\n            this.start = top\n            this.end = bottom\n            this.size = height\n        } else if (this.direction === 'row') {\n            this.start = left\n            this.end = right\n            this.size = width\n        }\n    }\n\n    getSizeAtTrack(track, end) {\n        return getSizeAtTrack(\n            track,\n            this.computedPixels,\n            this.computedGapPixels,\n            end,\n        )\n    }\n\n    getSizeOfTrack(track) {\n        return this.computedPixels[track].numeric\n    }\n\n    getRawTracks() {\n        const tracks = getStyles(\n            this.gridTemplateProp,\n            [this.grid],\n            getMatchedCSSRules(this.grid),\n        )\n        if (!tracks.length) {\n            if (this.optionStyle) return this.optionStyle\n\n            throw Error('Unable to determine grid template tracks from styles.')\n        }\n        return tracks[0]\n    }\n\n    getGap() {\n        const gap = getStyles(\n            this.gridGapProp,\n            [this.grid],\n            getMatchedCSSRules(this.grid),\n        )\n        if (!gap.length) {\n            return null\n        }\n        return gap[0]\n    }\n\n    getRawComputedTracks() {\n        return window.getComputedStyle(this.grid)[this.gridTemplateProp]\n    }\n\n    getRawComputedGap() {\n        return window.getComputedStyle(this.grid)[this.gridGapProp]\n    }\n\n    setTracks(raw) {\n        this.tracks = raw.split(' ')\n        this.trackValues = parse(raw)\n    }\n\n    setComputedTracks(raw) {\n        this.computedTracks = raw.split(' ')\n        this.computedPixels = parse(raw)\n    }\n\n    setGap(raw) {\n        this.gap = raw\n    }\n\n    setComputedGap(raw) {\n        this.computedGap = raw\n        this.computedGapPixels = getGapValue('px', this.computedGap) || 0\n    }\n\n    getMousePosition(e) {\n        if ('touches' in e) return e.touches[0][this.clientAxis]\n        return e[this.clientAxis]\n    }\n\n    startDragging(e) {\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault()\n\n        if (this.element) {\n            this.grid = this.element.parentNode\n        } else {\n            this.grid = e.target.parentNode\n        }\n\n        this.getDimensions()\n        this.setTracks(this.getRawTracks())\n        this.setComputedTracks(this.getRawComputedTracks())\n        this.setGap(this.getGap())\n        this.setComputedGap(this.getRawComputedGap())\n\n        const trackPercentage = this.trackValues.filter(\n            track => track.type === '%',\n        )\n        const trackFr = this.trackValues.filter(track => track.type === 'fr')\n\n        this.totalFrs = trackFr.length\n\n        if (this.totalFrs) {\n            const track = firstNonZero(trackFr)\n\n            if (track !== null) {\n                this.frToPixels =\n                    this.computedPixels[track].numeric / trackFr[track].numeric\n            }\n        }\n\n        if (trackPercentage.length) {\n            const track = firstNonZero(trackPercentage)\n\n            if (track !== null) {\n                this.percentageToPixels =\n                    this.computedPixels[track].numeric /\n                    trackPercentage[track].numeric\n            }\n        }\n\n        // get start of gutter track\n        const gutterStart = this.getSizeAtTrack(this.track, false) + this.start\n        this.dragStartOffset = this.getMousePosition(e) - gutterStart\n\n        this.aTrack = this.track - 1\n\n        if (this.track < this.tracks.length - 1) {\n            this.bTrack = this.track + 1\n        } else {\n            throw Error(\n                `Invalid track index: ${\n                    this.track\n                }. Track must be between two other tracks and only ${\n                    this.tracks.length\n                } tracks were found.`,\n            )\n        }\n\n        this.aTrackStart = this.getSizeAtTrack(this.aTrack, false) + this.start\n        this.bTrackEnd = this.getSizeAtTrack(this.bTrack, true) + this.start\n\n        // Set the dragging property of the pair object.\n        this.dragging = true\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        window.addEventListener('mouseup', this.stopDragging)\n        window.addEventListener('touchend', this.stopDragging)\n        window.addEventListener('touchcancel', this.stopDragging)\n        window.addEventListener('mousemove', this.drag)\n        window.addEventListener('touchmove', this.drag)\n\n        // Disable selection. Disable!\n        this.grid.addEventListener('selectstart', NOOP)\n        this.grid.addEventListener('dragstart', NOOP)\n\n        this.grid.style.userSelect = 'none'\n        this.grid.style.webkitUserSelect = 'none'\n        this.grid.style.MozUserSelect = 'none'\n        this.grid.style.pointerEvents = 'none'\n\n        // Set the cursor at multiple levels\n        this.grid.style.cursor = this.cursor\n        window.document.body.style.cursor = this.cursor\n\n        this.onDragStart(this.direction, this.track)\n    }\n\n    stopDragging() {\n        this.dragging = false\n\n        // Remove the stored event listeners. This is why we store them.\n        this.cleanup()\n\n        this.onDragEnd(this.direction, this.track)\n\n        if (this.needsDestroy) {\n            if (this.element) {\n                this.element.removeEventListener(\n                    'mousedown',\n                    this.startDragging,\n                )\n                this.element.removeEventListener(\n                    'touchstart',\n                    this.startDragging,\n                )\n            }\n            this.destroyCb()\n            this.needsDestroy = false\n            this.destroyCb = null\n        }\n    }\n\n    drag(e) {\n        let mousePosition = this.getMousePosition(e)\n\n        const gutterSize = this.getSizeOfTrack(this.track)\n        const minMousePosition =\n            this.aTrackStart +\n            this.minSizeStart +\n            this.dragStartOffset +\n            this.computedGapPixels\n        const maxMousePosition =\n            this.bTrackEnd -\n            this.minSizeEnd -\n            this.computedGapPixels -\n            (gutterSize - this.dragStartOffset)\n        const minMousePositionOffset = minMousePosition + this.snapOffset\n        const maxMousePositionOffset = maxMousePosition - this.snapOffset\n\n        if (mousePosition < minMousePositionOffset) {\n            mousePosition = minMousePosition\n        }\n\n        if (mousePosition > maxMousePositionOffset) {\n            mousePosition = maxMousePosition\n        }\n\n        if (mousePosition < minMousePosition) {\n            mousePosition = minMousePosition\n        } else if (mousePosition > maxMousePosition) {\n            mousePosition = maxMousePosition\n        }\n\n        let aTrackSize =\n            mousePosition -\n            this.aTrackStart -\n            this.dragStartOffset -\n            this.computedGapPixels\n        let bTrackSize =\n            this.bTrackEnd -\n            mousePosition +\n            this.dragStartOffset -\n            gutterSize -\n            this.computedGapPixels\n\n        if (this.dragInterval > 1) {\n            const aTrackSizeIntervaled =\n                Math.round(aTrackSize / this.dragInterval) * this.dragInterval\n            bTrackSize -= aTrackSizeIntervaled - aTrackSize\n            aTrackSize = aTrackSizeIntervaled\n        }\n\n        if (aTrackSize < this.minSizeStart) {\n            aTrackSize = this.minSizeStart\n        }\n\n        if (bTrackSize < this.minSizeEnd) {\n            bTrackSize = this.minSizeEnd\n        }\n\n        if (this.trackValues[this.aTrack].type === 'px') {\n            this.tracks[this.aTrack] = `${aTrackSize}px`\n        } else if (this.trackValues[this.aTrack].type === 'fr') {\n            if (this.totalFrs === 1) {\n                this.tracks[this.aTrack] = '1fr'\n            } else {\n                const targetFr = aTrackSize / this.frToPixels\n                this.tracks[this.aTrack] = `${targetFr}fr`\n            }\n        } else if (this.trackValues[this.aTrack].type === '%') {\n            const targetPercentage = aTrackSize / this.percentageToPixels\n            this.tracks[this.aTrack] = `${targetPercentage}%`\n        }\n\n        if (this.trackValues[this.bTrack].type === 'px') {\n            this.tracks[this.bTrack] = `${bTrackSize}px`\n        } else if (this.trackValues[this.bTrack].type === 'fr') {\n            if (this.totalFrs === 1) {\n                this.tracks[this.bTrack] = '1fr'\n            } else {\n                const targetFr = bTrackSize / this.frToPixels\n                this.tracks[this.bTrack] = `${targetFr}fr`\n            }\n        } else if (this.trackValues[this.bTrack].type === '%') {\n            const targetPercentage = bTrackSize / this.percentageToPixels\n            this.tracks[this.bTrack] = `${targetPercentage}%`\n        }\n\n        const style = this.tracks.join(' ')\n        this.writeStyle(this.grid, this.gridTemplateProp, style)\n        this.onDrag(this.direction, this.track, style)\n    }\n\n    cleanup() {\n        window.removeEventListener('mouseup', this.stopDragging)\n        window.removeEventListener('touchend', this.stopDragging)\n        window.removeEventListener('touchcancel', this.stopDragging)\n        window.removeEventListener('mousemove', this.drag)\n        window.removeEventListener('touchmove', this.drag)\n\n        if (this.grid) {\n            this.grid.removeEventListener('selectstart', NOOP)\n            this.grid.removeEventListener('dragstart', NOOP)\n\n            this.grid.style.userSelect = ''\n            this.grid.style.webkitUserSelect = ''\n            this.grid.style.MozUserSelect = ''\n            this.grid.style.pointerEvents = ''\n\n            this.grid.style.cursor = ''\n        }\n\n        window.document.body.style.cursor = ''\n    }\n\n    destroy(immediate = true, cb) {\n        if (immediate || this.dragging === false) {\n            this.cleanup()\n            if (this.element) {\n                this.element.removeEventListener(\n                    'mousedown',\n                    this.startDragging,\n                )\n                this.element.removeEventListener(\n                    'touchstart',\n                    this.startDragging,\n                )\n            }\n\n            if (cb) {\n                cb()\n            }\n        } else {\n            this.needsDestroy = true\n            if (cb) {\n                this.destroyCb = cb\n            }\n        }\n    }\n}\n\nconst getTrackOption = (options, track, defaultValue) => {\n    if (track in options) {\n        return options[track]\n    }\n\n    return defaultValue\n}\n\nconst createGutter = (direction, options) => gutterOptions => {\n    if (gutterOptions.track < 1) {\n        throw Error(\n            `Invalid track index: ${\n                gutterOptions.track\n            }. Track must be between two other tracks.`,\n        )\n    }\n\n    const trackMinSizes =\n        direction === 'column'\n            ? options.columnMinSizes || {}\n            : options.rowMinSizes || {}\n    const trackMinSize = direction === 'column' ? 'columnMinSize' : 'rowMinSize'\n\n    return new Gutter(\n        direction,\n        {\n            minSizeStart: getTrackOption(\n                trackMinSizes,\n                gutterOptions.track - 1,\n                getOption(\n                    options,\n                    trackMinSize,\n                    getOption(options, 'minSize', 0),\n                ),\n            ),\n            minSizeEnd: getTrackOption(\n                trackMinSizes,\n                gutterOptions.track + 1,\n                getOption(\n                    options,\n                    trackMinSize,\n                    getOption(options, 'minSize', 0),\n                ),\n            ),\n            ...gutterOptions,\n        },\n        options,\n    )\n}\n\nclass Grid {\n    constructor(options) {\n        this.columnGutters = {}\n        this.rowGutters = {}\n\n        this.options = {\n            columnGutters: options.columnGutters || [],\n            rowGutters: options.rowGutters || [],\n            columnMinSizes: options.columnMinSizes || {},\n            rowMinSizes: options.rowMinSizes || {},\n            ...options,\n        }\n\n        this.options.columnGutters.forEach(gutterOptions => {\n            this.columnGutters[gutterOptions.track] = createGutter(\n                'column',\n                this.options,\n            )(gutterOptions)\n        })\n\n        this.options.rowGutters.forEach(gutterOptions => {\n            this.rowGutters[gutterOptions.track] = createGutter('row', this.options)(\n                gutterOptions,\n            )\n        })\n    }\n\n    addColumnGutter(element, track) {\n        if (this.columnGutters[track]) {\n            this.columnGutters[track].destroy()\n        }\n\n        this.columnGutters[track] = createGutter('column', this.options)({\n            element,\n            track,\n        })\n    }\n\n    addRowGutter(element, track) {\n        if (this.rowGutters[track]) {\n            this.rowGutters[track].destroy()\n        }\n\n        this.rowGutters[track] = createGutter('row', this.options)({\n            element,\n            track,\n        })\n    }\n\n    removeColumnGutter(track, immediate = true) {\n        if (this.columnGutters[track]) {\n            this.columnGutters[track].destroy(immediate, () => {\n                delete this.columnGutters[track]\n            })\n        }\n    }\n\n    removeRowGutter(track, immediate = true) {\n        if (this.rowGutters[track]) {\n            this.rowGutters[track].destroy(immediate, () => {\n                delete this.rowGutters[track]\n            })\n        }\n    }\n\n    handleDragStart(e, direction, track) {\n        if (direction === 'column') {\n            if (this.columnGutters[track]) {\n                this.columnGutters[track].destroy()\n            }\n\n            this.columnGutters[track] = createGutter('column', this.options)({\n                track,\n            })\n            this.columnGutters[track].startDragging(e)\n        } else if (direction === 'row') {\n            if (this.rowGutters[track]) {\n                this.rowGutters[track].destroy()\n            }\n\n            this.rowGutters[track] = createGutter('row', this.options)({\n                track,\n            })\n            this.rowGutters[track].startDragging(e)\n        }\n    }\n\n    destroy(immediate = true) {\n        Object.keys(this.columnGutters).forEach(track =>\n            this.columnGutters[track].destroy(immediate, () => {\n                delete this.columnGutters[track]\n            }),\n        )\n        Object.keys(this.rowGutters).forEach(track =>\n            this.rowGutters[track].destroy(immediate, () => {\n                delete this.rowGutters[track]\n            }),\n        )\n    }\n}\n\nexport default options => new Grid(options)\n"],"names":["getStyles","rule","ownRules","matchedRules","map","r","style","filter","undefined","firstNonZero","tracks","let","i","length","numeric","value","unit","Number","slice","parseValue","endsWith","type","parse","split","el","concat","ref","Array","from","ownerDocument","styleSheets","s","rules","cssRules","e","matches","selectorText","NOOP","defaultWriteStyle","element","gridTemplateProp","getOption","options","propName","def","const","Gutter","direction","parentOptions","this","track","gridGapProp","cursor","snapOffset","dragInterval","clientAxis","optionStyle","onDragStart","onDragEnd","onDrag","writeStyle","startDragging","bind","stopDragging","drag","minSizeStart","minSizeEnd","addEventListener","getDimensions","grid","getBoundingClientRect","start","top","end","bottom","size","height","left","right","width","getSizeAtTrack","index","gap","newIndex","reduce","accum","computedPixels","computedGapPixels","getSizeOfTrack","getRawTracks","getMatchedCSSRules","Error","getGap","getRawComputedTracks","window","getComputedStyle","getRawComputedGap","setTracks","raw","trackValues","setComputedTracks","computedTracks","setGap","setComputedGap","computedGap","getGapValue","getMousePosition","touches","button","preventDefault","parentNode","target","trackPercentage","trackFr","totalFrs","frToPixels","percentageToPixels","gutterStart","dragStartOffset","aTrack","bTrack","aTrackStart","bTrackEnd","dragging","userSelect","webkitUserSelect","MozUserSelect","pointerEvents","document","body","cleanup","needsDestroy","removeEventListener","destroyCb","mousePosition","gutterSize","minMousePosition","maxMousePosition","aTrackSize","bTrackSize","aTrackSizeIntervaled","Math","round","targetFr","targetPercentage","targetFr$1","targetPercentage$1","join","destroy","immediate","cb","getTrackOption","defaultValue","createGutter","gutterOptions","trackMinSizes","columnMinSizes","rowMinSizes","trackMinSize","Object","Grid","columnGutters","rowGutters","forEach","this$1","addColumnGutter","addRowGutter","removeColumnGutter","removeRowGutter","handleDragStart","keys"],"mappings":";0LAAaA,EAAaC,EAAMC,EAAUC,UAClCD,SAAaC,GACZC,aAAIC,UAAKA,EAAEC,MAAML,KACjBM,gBAAOD,eAAmBE,IAAVF,GAAiC,KAAVA,aASnCG,EAAeC,GAExB,IAAKC,IAAIC,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAC/B,GAAwB,EAApBF,EAAOE,GAAGE,QACV,OAAOF,EAGf,OAAO,cAGLE,EAAWC,EAAOC,UAASC,OAAOF,EAAMG,MAAM,GAAI,EAAIF,EAAKH,kBAE3DM,EAAaJ,GACf,OAAIA,EAAMK,SAAS,MACR,OAAEL,EAAOM,KAAM,KAAMP,QAASA,EAAQC,EAAO,OACpDA,EAAMK,SAAS,MACR,OAAEL,EAAOM,KAAM,KAAMP,QAASA,EAAQC,EAAO,OACpDA,EAAMK,SAAS,KACR,OAAEL,EAAOM,KAAM,IAAKP,QAASA,EAAQC,EAAO,MACzC,SAAVA,EAAyB,OAAEA,EAAOM,KAAM,QACrC,cAGEC,EAAQrB,UAAQA,EAAKsB,MAAM,KAAKnB,IAAIe,cCnClCK,kBACX,IACKC,aACGC,EAAGC,MAAMC,KAAKJ,EAAGK,cAAcC,aAAa1B,aAAI2B,GAC5CpB,IAAIqB,EAAQ,GAEZ,IACIA,EAAQL,MAAMC,KAAKG,EAAEE,UAAY,IACnC,MAAOC,IAIT,OAAOF,KAGdzB,gBAAOF,GACJM,IAAIwB,GAAU,EACd,IACIA,EAAUX,EAAGW,QAAQ9B,EAAE+B,cACzB,MAAOF,IAIT,OAAOC,aCjBbE,WAAa,WAEbC,EAAqBC,EAASC,EAAkBlC,GAElDiC,EAAQjC,MAAMkC,GAAoBlC,WAGhCmC,EAAaC,EAASC,EAAUC,GAClCC,IAAM9B,EAAQ2B,EAAQC,GACtB,YAAcnC,IAAVO,EACOA,EAEJ6B,EAIP,SADEE,EACUC,EAAWL,EAASM,GAC5BC,KAAKF,UAAYA,EACjBE,KAAKV,QAAUG,EAAQH,QACvBU,KAAKC,MAAQR,EAAQQ,MAEH,WAAdH,GACAE,KAAKT,iBAzBe,wBA0BpBS,KAAKE,YAAc,kBACnBF,KAAKG,OAASX,EACVO,EACA,eACJP,EAAcO,EAAe,SAAU,eAEvCC,KAAKI,WAAaZ,EACdO,EACA,mBACJP,EAAcO,EAAe,aAAc,KAE3CC,KAAKK,aAAeb,EAChBO,EACA,qBACJP,EAAcO,EAAe,eAAgB,IAE7CC,KAAKM,WAAa,UACtBN,KAASO,YAAcf,EAAUO,EAAe,wBACvB,QAAdD,IACPE,KAAKT,iBA5CY,qBA6CjBS,KAAKE,YAAc,eACnBF,KAAKG,OAASX,EACVO,EACA,YACJP,EAAcO,EAAe,SAAU,eAEvCC,KAAKI,WAAaZ,EACdO,EACA,gBACJP,EAAcO,EAAe,aAAc,KAE3CC,KAAKK,aAAeb,EAChBO,EACA,kBACJP,EAAcO,EAAe,eAAgB,IAE7CC,KAAKM,WAAa,UACtBN,KAASO,YAAcf,EAAUO,EAAe,qBAGpDC,KAASQ,YAAchB,EAAUO,EAAe,cAAeX,GAC/DY,KAASS,UAAYjB,EAAUO,EAAe,YAAaX,GAC3DY,KAASU,OAASlB,EAAUO,EAAe,SAAUX,GACjDY,KAAKW,WAAanB,EACdO,EACA,aACAV,GAGRW,KAASY,cAAgBZ,KAAKY,cAAcC,KAAKb,MACjDA,KAASc,aAAed,KAAKc,aAAaD,KAAKb,MAC/CA,KAASe,KAAOf,KAAKe,KAAKF,KAAKb,MAE3BA,KAAKgB,aAAevB,EAAQuB,aAC5BhB,KAAKiB,WAAaxB,EAAQwB,WAEtBxB,EAAQH,UACZU,KAASV,QAAQ4B,iBAAiB,YAAalB,KAAKY,eACpDZ,KAASV,QAAQ4B,iBAAiB,aAAclB,KAAKY,gBAI7Df,YAAIsB,yBACA,MAOQnB,KAAKoB,KAAKC,mFAES,WAAnBrB,KAAKF,WACLE,KAAKsB,MAAQC,EACbvB,KAAKwB,IAAMC,EACXzB,KAAK0B,KAAOC,GACc,QAAnB3B,KAAKF,YACZE,KAAKsB,MAAQM,EACb5B,KAAKwB,IAAMK,EACX7B,KAAK0B,KAAOI,IAIxBjC,YAAIkC,wBAAe9B,EAAOuB,GAClB,gBFxDuBQ,EAAOvE,EAAQwE,EAAST,kBAAH,mBAAS,GACzD5B,IAAMsC,EAAWV,EAAMQ,EAAQ,EAAIA,EAMnC,OALiBvE,EACZQ,MAAM,EAAGiE,GACTC,gBAAQC,EAAOtE,UAAUsE,EAAQtE,EAAMD,SAAS,IACtCoE,EAAMD,EAAQC,EAAM,GEmDxBF,CACH9B,EACJD,KAASqC,eACTrC,KAASsC,kBACLd,IAIZ3B,YAAI0C,wBAAetC,GACf,OAAWD,KAAKqC,eAAepC,GAAOpC,SAG1CgC,YAAI2C,wBACI5C,IAAMnC,EAASV,EACfiD,KAAST,iBACL,CAACS,KAAKoB,MACNqB,EAAmBzC,KAAKoB,OAE5B,GAAK3D,EAAOG,OAKZ,OAAOH,EAAO,GAJd,GAAQuC,KAAKO,YAAa,OAAOP,KAAKO,YAElC,MAAMmC,MAAM,0DAKxB7C,YAAI8C,kBACI/C,IAAMqC,EAAMlF,EACZiD,KAASE,YACL,CAACF,KAAKoB,MACNqB,EAAmBzC,KAAKoB,OAE5B,OAAKa,EAAIrE,OAGFqE,EAAI,GAFA,MAKnBpC,YAAI+C,gCACI,OAAOC,OAAOC,iBAAiB9C,KAAKoB,MAAMpB,KAAKT,mBAGvDM,YAAIkD,6BACI,OAAOF,OAAOC,iBAAiB9C,KAAKoB,MAAMpB,KAAKE,cAGvDL,YAAImD,mBAAUC,GACVjD,KAASvC,OAASwF,EAAI3E,MAAM,KACxB0B,KAAKkD,YAAc7E,EAAM4E,IAGjCpD,YAAIsD,2BAAkBF,GAClBjD,KAASoD,eAAiBH,EAAI3E,MAAM,KAChC0B,KAAKqC,eAAiBhE,EAAM4E,IAGpCpD,YAAIwD,gBAAOJ,GACHjD,KAAKiC,IAAMgB,GAGnBpD,YAAIyD,wBAAeL,GACXjD,KAAKuD,YAAcN,EACnBjD,KAAKsC,2BF1KevE,EAAM2D,GAC9B,OAAIA,EAAKvD,SAASJ,GACPC,OAAO0D,EAAKzD,MAAM,GAAI,EAAIF,EAAKH,SAEnC,KEsKsB4F,CAAY,KAAMxD,KAAKuD,cAAgB,GAGxE1D,YAAI4D,0BAAiBxE,GACb,MAAI,YAAaA,EAAUA,EAAEyE,QAAQ,GAAG1D,KAAKM,YACtCrB,EAAEe,KAAKM,aAGtBT,YAAIe,uBAAc3B,GACd,KAAQ,WAAYA,GAAkB,IAAbA,EAAE0E,QAA3B,CAKA1E,EAAM2E,iBAEE5D,KAAKV,QACTU,KAASoB,KAAOpB,KAAKV,QAAQuE,WAE7B7D,KAASoB,KAAOnC,EAAE6E,OAAOD,WAG7B7D,KAASmB,gBACTnB,KAASgD,UAAUhD,KAAKwC,gBACxBxC,KAASmD,kBAAkBnD,KAAK4C,wBAChC5C,KAASqD,OAAOrD,KAAK2C,UACrB3C,KAASsD,eAAetD,KAAK+C,qBAE7B,IAAUgB,EAAkB/D,KAAKkD,YAAY5F,OACzC,SAAI2C,SAAwB,MAAfA,EAAM7B,OAEb4F,EAAUhE,KAAKkD,YAAY5F,gBAAO2C,SAAwB,OAAfA,EAAM7B,OAIvD,GAFA4B,KAAKiE,SAAWD,EAAQpG,OAEpBoC,KAAKiE,SAAU,CACfrE,IAAMK,EAAQzC,EAAawG,GAEb,OAAV/D,IACJD,KAASkE,WACDlE,KAAKqC,eAAepC,GAAOpC,QAAUmG,EAAQ/D,GAAOpC,SAIhE,GAAIkG,EAAgBnG,OAAQ,CACxBgC,IAAMK,EAAQzC,EAAauG,GAEb,OAAV9D,IACJD,KAASmE,mBACDnE,KAAKqC,eAAepC,GAAOpC,QAC3BkG,EAAgB9D,GAAOpC,SAKnC+B,IAAMwE,EAAcpE,KAAK+B,eAAe/B,KAAKC,OAAO,GAASD,KAAKsB,MAKlE,GAJJtB,KAASqE,gBAAkBrE,KAAKyD,iBAAiBxE,GAAKmF,EAEtDpE,KAASsE,OAAStE,KAAKC,MAAQ,IAEvBD,KAAKC,MAAQD,KAAKvC,OAAOG,OAAS,GAGlC,MAAM8E,8BAEE1C,gEAEAA,KAAKvC,qCANjBuC,KAASuE,OAASvE,KAAKC,MAAQ,EAW/BD,KAAKwE,YAAcxE,KAAK+B,eAAe/B,KAAKsE,QAAQ,GAAStE,KAAKsB,MAClEtB,KAAKyE,UAAYzE,KAAK+B,eAAe/B,KAAKuE,QAAQ,GAAQvE,KAAKsB,MAG/DtB,KAAK0E,UAAW,EAGpB7B,OAAW3B,iBAAiB,UAAWlB,KAAKc,cAC5C+B,OAAW3B,iBAAiB,WAAYlB,KAAKc,cAC7C+B,OAAW3B,iBAAiB,cAAelB,KAAKc,cAChD+B,OAAW3B,iBAAiB,YAAalB,KAAKe,MAC9C8B,OAAW3B,iBAAiB,YAAalB,KAAKe,MAG9Cf,KAASoB,KAAKF,iBAAiB,cAAe9B,GAC9CY,KAASoB,KAAKF,iBAAiB,YAAa9B,GAE5CY,KAASoB,KAAK/D,MAAMsH,WAAa,OACjC3E,KAASoB,KAAK/D,MAAMuH,iBAAmB,OACvC5E,KAASoB,KAAK/D,MAAMwH,cAAgB,OACpC7E,KAASoB,KAAK/D,MAAMyH,cAAgB,OAGpC9E,KAASoB,KAAK/D,MAAM8C,OAASH,KAAKG,OAC9B0C,OAAOkC,SAASC,KAAK3H,MAAM8C,OAASH,KAAKG,OAE7CH,KAASQ,YAAYR,KAAKF,UAAWE,KAAKC,SAG9CJ,YAAIiB,wBACId,KAAK0E,UAAW,EAGpB1E,KAASiF,UAETjF,KAASS,UAAUT,KAAKF,UAAWE,KAAKC,OAEhCD,KAAKkF,eACDlF,KAAKV,UACLU,KAAKV,QAAQ6F,oBACT,YACJnF,KAASY,eAETZ,KAAKV,QAAQ6F,oBACT,aACJnF,KAASY,gBAGjBZ,KAASoF,YACLpF,KAAKkF,cAAe,EACpBlF,KAAKoF,UAAY,OAI7BvF,YAAIkB,cAAK9B,GACL,IAAQoG,EAAgBrF,KAAKyD,iBAAiBxE,GAEpCqG,EAAatF,KAAKuC,eAAevC,KAAKC,OACtCsF,EACNvF,KAASwE,YACTxE,KAASgB,aACThB,KAASqE,gBACTrE,KAASsC,kBACHkD,EACNxF,KAASyE,UACTzE,KAASiB,WACTjB,KAASsC,mBACJgD,EAAatF,KAAKqE,iBAInBgB,EAH2BE,EAAmBvF,KAAKI,aAIvDiF,EAAoBE,GAHWC,EAAmBxF,KAAKI,WAMnDiF,IACJA,EAAoBG,GAGhBH,EAAgBE,EACpBF,EAAoBE,EACOC,EAAhBH,IACXA,EAAoBG,GAGxB,IAAQC,EACAJ,EACJrF,KAASwE,YACTxE,KAASqE,gBACTrE,KAASsC,kBACLoD,EACJ1F,KAASyE,UACLY,EACJrF,KAASqE,gBACLiB,EACJtF,KAASsC,kBAET,GAAwB,EAApBtC,KAAKK,aAAkB,CAC3B,IAAUsF,EACFC,KAAKC,MAAMJ,EAAazF,KAAKK,cAAgBL,KAAKK,aACtDqF,GAAcC,EAAuBF,EACzCA,EAAiBE,EAWjB,GARIF,EAAazF,KAAKgB,eAClByE,EAAazF,KAAKgB,cAGlB0E,EAAa1F,KAAKiB,aAClByE,EAAa1F,KAAKiB,YAGqB,OAAvCjB,KAAKkD,YAAYlD,KAAKsE,QAAQlG,KAClC4B,KAASvC,OAAOuC,KAAKsE,QAAUmB,YACxB,GAA2C,OAAvCzF,KAAKkD,YAAYlD,KAAKsE,QAAQlG,KACrC,GAAsB,IAAlB4B,KAAKiE,SACTjE,KAASvC,OAAOuC,KAAKsE,QAAU,UACxB,CACP,IAAUwB,EAAWL,EAAazF,KAAKkE,WACvClE,KAASvC,OAAOuC,KAAKsE,QAAUwB,YAE5B,GAA2C,MAAvC9F,KAAKkD,YAAYlD,KAAKsE,QAAQlG,KAAc,CACvD,IAAU2H,EAAmBN,EAAazF,KAAKmE,mBAC/CnE,KAASvC,OAAOuC,KAAKsE,QAAUyB,MAG/B,GAA2C,OAAvC/F,KAAKkD,YAAYlD,KAAKuE,QAAQnG,KAClC4B,KAASvC,OAAOuC,KAAKuE,QAAUmB,YACxB,GAA2C,OAAvC1F,KAAKkD,YAAYlD,KAAKuE,QAAQnG,KACrC,GAAsB,IAAlB4B,KAAKiE,SACTjE,KAASvC,OAAOuC,KAAKuE,QAAU,UACxB,CACP,IAAUuB,EAAWJ,EAAa1F,KAAKkE,WACvClE,KAASvC,OAAOuC,KAAKuE,QAAUyB,YAE5B,GAA2C,MAAvChG,KAAKkD,YAAYlD,KAAKuE,QAAQnG,KAAc,CACvD,IAAU2H,EAAmBL,EAAa1F,KAAKmE,mBAC/CnE,KAASvC,OAAOuC,KAAKuE,QAAU0B,MAGnC,IAAU5I,EAAQ2C,KAAKvC,OAAOyI,KAAK,KAC/BlG,KAAKW,WAAWX,KAAKoB,KAAMpB,KAAKT,iBAAkBlC,GAClD2C,KAAKU,OAAOV,KAAKF,UAAWE,KAAKC,MAAO5C,IAGhDwC,YAAIoF,mBACApC,OAAWsC,oBAAoB,UAAWnF,KAAKc,cAC/C+B,OAAWsC,oBAAoB,WAAYnF,KAAKc,cAChD+B,OAAWsC,oBAAoB,cAAenF,KAAKc,cACnD+B,OAAWsC,oBAAoB,YAAanF,KAAKe,MACjD8B,OAAWsC,oBAAoB,YAAanF,KAAKe,MAEzCf,KAAKoB,OACTpB,KAASoB,KAAK+D,oBAAoB,cAAe/F,GACjDY,KAASoB,KAAK+D,oBAAoB,YAAa/F,GAE/CY,KAASoB,KAAK/D,MAAMsH,WAAa,GACjC3E,KAASoB,KAAK/D,MAAMuH,iBAAmB,GACvC5E,KAASoB,KAAK/D,MAAMwH,cAAgB,GACpC7E,KAASoB,KAAK/D,MAAMyH,cAAgB,GAEpC9E,KAASoB,KAAK/D,MAAM8C,OAAS,IAGjC0C,OAAWkC,SAASC,KAAK3H,MAAM8C,OAAS,IAG5CN,YAAIsG,iBAAQC,EAAkBC,mBAAN,GACZD,IAA+B,IAAlBpG,KAAK0E,UACtB1E,KAASiF,UACDjF,KAAKV,UACLU,KAAKV,QAAQ6F,oBACT,YACJnF,KAASY,eAETZ,KAAKV,QAAQ6F,oBACT,aACJnF,KAASY,gBAITyF,GACAA,MAGJrG,KAAKkF,cAAe,EAChBmB,IACArG,KAAKoF,UAAYiB,cAM3BC,EAAkB7G,EAASQ,EAAOsG,GACpC,OAAItG,KAASR,EACFA,EAAQQ,GAGZsG,WAGLC,EAAgB1G,EAAWL,mBAAYgH,GACzC,GAAIA,EAAcxG,MAAQ,EACtB,MAAMyC,8BAEE+D,qDAKZ7G,IAAM8G,EACY,WAAd5G,EACML,EAAQkH,gBAAkB,GAC1BlH,EAAQmH,aAAe,GAC3BC,EAA6B,WAAd/G,EAAyB,gBAAkB,aAEhE,OAAO,IAAID,EACPC,EACAgH,kBACI9F,aAAcsF,EACVI,EACAD,EAAcxG,MAAQ,EACtBT,EACIC,EACAoH,EACArH,EAAUC,EAAS,UAAW,KAGtCwB,WAAYqF,EACRI,EACAD,EAAcxG,MAAQ,EACtBT,EACIC,EACAoH,EACArH,EAAUC,EAAS,UAAW,MAGnCgH,GAEPhH,IAKJ,SADEsH,EACUtH,cACRO,KAAKgH,cAAgB,GACrBhH,KAAKiH,WAAa,GAEtBjH,KAASP,QAAUqH,kBACXE,cAAevH,EAAQuH,eAAiB,GACxCC,WAAYxH,EAAQwH,YAAc,GAClCN,eAAgBlH,EAAQkH,gBAAkB,GAC1CC,YAAanH,EAAQmH,aAAe,IACjCnH,GAGXO,KAASP,QAAQuH,cAAcE,iBAAQT,GACnCU,EAASH,cAAcP,EAAcxG,OAASuG,EACtC,SACJW,EAAS1H,QAFiC+G,CAGxCC,KAGVzG,KAASP,QAAQwH,WAAWC,iBAAQT,GAC5BzG,EAAKiH,WAAWR,EAAcxG,OAASuG,EAAa,MAAOxG,EAAKP,QAAzB+G,CACnCC,YAKhBM,YAAIK,yBAAgB9H,EAASW,GACjBD,KAAKgH,cAAc/G,IACvBD,KAASgH,cAAc/G,GAAOkG,UAG9BnG,KAAKgH,cAAc/G,GAASuG,EAAa,SAAUxG,KAAKP,QAA5B+G,CAAqC,CACjElH,QAAIA,EACJW,MAAIA,KAIZ8G,YAAIM,sBAAa/H,EAASW,GACdD,KAAKiH,WAAWhH,IACpBD,KAASiH,WAAWhH,GAAOkG,UAG3BnG,KAAKiH,WAAWhH,GAASuG,EAAa,MAAOxG,KAAKP,QAAzB+G,CAAkC,CAC3DlH,QAAIA,EACJW,MAAIA,KAIZ8G,YAAIO,4BAAmBrH,EAAOmG,8BAAY,GAC9BpG,KAAKgH,cAAc/G,IACnBD,KAAKgH,cAAc/G,GAAOkG,QAAQC,oBACvBpG,EAAKgH,cAAc/G,MAK1C8G,YAAIQ,yBAAgBtH,EAAOmG,8BAAY,GAC3BpG,KAAKiH,WAAWhH,IAChBD,KAAKiH,WAAWhH,GAAOkG,QAAQC,oBACpBpG,EAAKiH,WAAWhH,MAKvC8G,YAAIS,yBAAgBvI,EAAGa,EAAWG,GACR,WAAdH,GACIE,KAAKgH,cAAc/G,IACvBD,KAASgH,cAAc/G,GAAOkG,UAG9BnG,KAAKgH,cAAc/G,GAASuG,EAAa,SAAUxG,KAAKP,QAA5B+G,CAAqC,CACjEvG,MAAIA,IAERD,KAASgH,cAAc/G,GAAOW,cAAc3B,IACnB,QAAda,IACHE,KAAKiH,WAAWhH,IACpBD,KAASiH,WAAWhH,GAAOkG,UAG3BnG,KAAKiH,WAAWhH,GAASuG,EAAa,MAAOxG,KAAKP,QAAzB+G,CAAkC,CAC3DvG,MAAIA,IAERD,KAASiH,WAAWhH,GAAOW,cAAc3B,KAIjD8H,YAAIZ,iBAAQC,8BAAY,GACpBU,OAAWW,KAAKzH,KAAKgH,eAAeE,iBAAQjH,UACpCD,EAAKgH,cAAc/G,GAAOkG,QAAQC,oBACvBpG,EAAKgH,cAAc/G,OAGtC6G,OAAWW,KAAKzH,KAAKiH,YAAYC,iBAAQjH,UACjCD,EAAKiH,WAAWhH,GAAOkG,QAAQC,oBACpBpG,EAAKiH,WAAWhH,iBAMxBR,UAAW,IAAIsH,EAAKtH"}